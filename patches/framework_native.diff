diff --git a/include/binder/MemoryHeapIon.h b/include/binder/MemoryHeapIon.h
index 7e059f4..1715e25 100644
--- a/include/binder/MemoryHeapIon.h
+++ b/include/binder/MemoryHeapIon.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
- * Copyright 2011, Samsung Electronics Co. LTD
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,55 +14,59 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*!
- * \file MemoryHeapIon.h
- * \brief header file for MemoryHeapIon
- * \author MinGu, Jeon(mingu85.jeon)
- * \date 2011/11/20
- *
- * <b>Revision History: </b>
- * - 2011/11/21 : MinGu, Jeon(mingu85.jeon)) \n
- * Initial version
- * - 2012/11/29 : MinGu, Jeon(mingu85.jeon)) \n
- * Change name
- */
 
 #ifndef ANDROID_MEMORY_HEAP_ION_H
 #define ANDROID_MEMORY_HEAP_ION_H
 
-#include <binder/IMemory.h>
-#include <binder/MemoryHeapBase.h>
 #include <stdlib.h>
+#include <stdint.h>
 
-#define MHB_ION_HEAP_SYSTEM_CONTIG_MASK     (1 << 1)
-#define MHB_ION_HEAP_EXYNOS_CONTIG_MASK     (1 << 4)
-#define MHB_ION_HEAP_EXYNOS_MASK            (1 << 5)
-#define MHB_ION_HEAP_SYSTEM_MASK            (1 << 6)
-
-#define MHB_ION_FLAG_CACHED                 (1 << 16)
-#define MHB_ION_FLAG_CACHED_NEEDS_SYNC      (1 << 17)
-#define MHB_ION_FLAG_PRESERVE_KMAP          (1 << 18)
+#include <binder/MemoryHeapBase.h>
+#include <binder/IMemory.h>
+#include <utils/SortedVector.h>
+#include <utils/threads.h>
 
-#define MHB_ION_EXYNOS_VIDEO_MASK           (1 << 21)
-#define MHB_ION_EXYNOS_MFC_INPUT_MASK       (1 << 25)
-#define MHB_ION_EXYNOS_MFC_OUTPUT_MASK      (1 << 26)
-#define MHB_ION_EXYNOS_GSC_MASK             (1 << 27)
-#define MHB_ION_EXYNOS_FIMD_VIDEO_MASK      (1 << 28)
+struct ion_handle;
 
 namespace android {
 
+class MemoryHeapBase;
+
+// ---------------------------------------------------------------------------
+
 class MemoryHeapIon : public MemoryHeapBase
 {
 public:
-    enum {
-        USE_ION_FD = IMemoryHeap::USE_ION_FD
-    };
-    MemoryHeapIon(size_t size, uint32_t flags = 0, char const* name = NULL);
-    MemoryHeapIon(int fd, size_t size, uint32_t flags = 0, uint32_t offset = 0);
+    MemoryHeapIon(const char*, size_t, uint32_t, long unsigned int);
+    MemoryHeapIon();
     ~MemoryHeapIon();
+
+    status_t mapIonFd(int fd, size_t size, unsigned long memory_type, int flags);
+
+    status_t ionInit(int ionFd, void *base, int size, int flags,
+                                const char* device, struct ion_handle *handle,
+                                int ionMapFd);
+    int get_phy_addr_from_ion(int *phy_addr, int *size);
+    int flush_ion_buffer(void *v_addr, void *p_addr,int size);
+    int get_gsp_iova(int *mmu_addr, int *size);
+    int free_gsp_iova(int mmu_addr, int size);
+    int get_mm_iova(int *mmu_addr, int *size);
+    int free_mm_iova(int mmu_addr, int size);
+    static int Get_gsp_iova(int buffer_fd, int *mmu_addr, int *size);
+    static int Free_gsp_iova(int buffer_fd, int mmu_addr, int size);
+    static int Get_mm_iova(int buffer_fd,int *mmu_addr, int *size);
+    static int Free_mm_iova(int buffer_fd,int mmu_addr, int size);
+    static int Get_phy_addr_from_ion(int fd, int *phy_addr, int *size);/*fd is "fd of the corresponding ion hanlde"*/
+    static int Flush_ion_buffer(int buffer_fd, void *v_addr,void *p_addr, int size);
+    static bool Gsp_iommu_is_enabled(void);
+    static bool Mm_iommu_is_enabled(void);
+
 private:
-    int mIonClient;
-};
+    int mIonDeviceFd;  /*fd we get from open("/dev/ion")*/
+    struct ion_handle *mIonHandle;  /*handle we get from ION_IOC_ALLOC*/ };
+
+// ---------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_MEMORY_HEAP_ION_H
 
-};
-#endif
diff --git a/include/gui/ISurfaceComposer.h b/include/gui/ISurfaceComposer.h
index 6e3fc5a..0db2e83 100644
--- a/include/gui/ISurfaceComposer.h
+++ b/include/gui/ISurfaceComposer.h
@@ -149,6 +149,19 @@ public:
             bool useIdentityTransform,
             Rotation rotation = eRotateNone,
             bool isCpuConsumer = false) = 0;
+            
+#ifdef USE_MHEAP_SCREENSHOT
+    /* Capture the specified screen. requires READ_FRAME_BUFFER permission
+     * This function will fail if there is a secure window on screen.
+     */
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform,
+            Rotation rotation = eRotateNone) = 0;
+#endif
+
 
     /* Clears the frame statistics for animations.
      *
@@ -179,6 +192,9 @@ public:
         GET_BUILT_IN_DISPLAY,
         SET_TRANSACTION_STATE,
         AUTHENTICATE_SURFACE,
+#ifdef USE_MHEAP_SCREENSHOT
+        CAPTURE_SCREEN_DEPRECATED,
+#endif
         GET_DISPLAY_CONFIGS,
         GET_ACTIVE_CONFIG,
         SET_ACTIVE_CONFIG,
diff --git a/include/gui/SurfaceComposerClient.h b/include/gui/SurfaceComposerClient.h
index 9ec3f23..ec83b02 100644
--- a/include/gui/SurfaceComposerClient.h
+++ b/include/gui/SurfaceComposerClient.h
@@ -40,6 +40,9 @@ namespace android {
 
 class DisplayInfo;
 class Composer;
+#ifdef USE_MHEAP_SCREENSHOT
+class IMemoryHeap;
+#endif
 class ISurfaceComposerClient;
 class IGraphicBufferProducer;
 class Region;
@@ -193,6 +196,9 @@ public:
             bool useIdentityTransform);
 
 private:
+#ifdef USE_MHEAP_SCREENSHOT
+    sp<IMemoryHeap> mHeap;
+#endif
     mutable sp<CpuConsumer> mCpuConsumer;
     mutable sp<IGraphicBufferProducer> mProducer;
     CpuConsumer::LockedBuffer mBuffer;
diff --git a/include/ui/FramebufferNativeWindow.h b/include/ui/FramebufferNativeWindow.h
index 6b66d5f..d79a111 100644
--- a/include/ui/FramebufferNativeWindow.h
+++ b/include/ui/FramebufferNativeWindow.h
@@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 #ifndef INCLUDED_FROM_FRAMEBUFFER_NATIVE_WINDOW_CPP
-#warning "FramebufferNativeWindow is deprecated"
+//#warning "FramebufferNativeWindow is deprecated"
 #endif
 
 #ifndef ANDROID_FRAMEBUFFER_NATIVE_WINDOW_H
diff --git a/libs/binder/Android.mk b/libs/binder/Android.mk
index b12eda8..3b86e46 100644
--- a/libs/binder/Android.mk
+++ b/libs/binder/Android.mk
@@ -37,6 +37,7 @@ sources := \
     ProcessState.cpp \
     Static.cpp \
     TextOutput.cpp \
+    MemoryHeapIon.cpp \
 
 ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
 sources += \
diff --git a/libs/binder/MemoryHeapIon.cpp b/libs/binder/MemoryHeapIon.cpp
index 26c5566..2785185 100644
--- a/libs/binder/MemoryHeapIon.cpp
+++ b/libs/binder/MemoryHeapIon.cpp
@@ -1,12 +1,12 @@
 /*
- * Copyright Samsung Electronics Co.,LTD.
- * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- * http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -14,178 +14,487 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*!
- * \file MemoryHeapIon.cpp
- * \brief source file for MemoryHeapIon
- * \author MinGu, Jeon(mingu85.jeon)
- * \date 2011/11/20
- *
- * <b>Revision History: </b>
- * - 2011/11/20 : MinGu, Jeon(mingu85.jeon)) \n
- * Initial version
- * - 2012/11/29 : MinGu, Jeon(mingu85.jeon)) \n
- * Change name
- */
+
+#define LOG_TAG "MemoryHeapIon"
 
 #include <stdlib.h>
 #include <stdint.h>
 #include <unistd.h>
 #include <fcntl.h>
+#include <errno.h>
 #include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+
 #include <cutils/log.h>
-#include <binder/MemoryHeapBase.h>
-#include <binder/IMemory.h>
+
 #include <binder/MemoryHeapIon.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-#include "ion.h"
+#include <binder/MemoryHeapBase.h>
+
+#ifdef USE_TARGET_SIMULATOR_MODE
+#include <linux/ion.h>
+//modify for make sdk
+struct ion_phys_data {
+    int fd_buffer;
+    unsigned long phys;
+    size_t size;
+};
+
+struct ion_msync_data {
+    int fd_buffer;
+    void *vaddr;
+    void *paddr;
+    size_t size;
+};
 
-#define HEAP_MASK_FILTER    ((1 << 16) - (2))
-#define FLAG_MASK_FILTER    (~(HEAP_MASK_FILTER) - (1))
+enum ION_SPRD_CUSTOM_CMD {
+    ION_SPRD_CUSTOM_PHYS,
+    ION_SPRD_CUSTOM_MSYNC
+};
+#else
+#include "ion.h"
+#include "ion_sprd.h"
+#endif
 
 namespace android {
 
-uint32_t ion_HeapMask_valid_check(uint32_t flags)
-{
-    uint32_t heap_mask, result;
-    result = 0;
-
-    heap_mask = flags & HEAP_MASK_FILTER;
-
-    switch(heap_mask) {
-        case MHB_ION_HEAP_SYSTEM_MASK:
-            return ION_HEAP_SYSTEM_MASK;
-        case MHB_ION_HEAP_SYSTEM_CONTIG_MASK:
-            return ION_HEAP_SYSTEM_CONTIG_MASK;
-        case MHB_ION_HEAP_EXYNOS_CONTIG_MASK:
-            return ION_HEAP_EXYNOS_CONTIG_MASK;
-        case MHB_ION_HEAP_EXYNOS_MASK:
-            return ION_HEAP_EXYNOS_MASK;
-        default:
-            ALOGE("MemoryHeapIon : Heap Mask flag is default (flags:%x)", flags);
-            return 0;
-            break;
+int  MemoryHeapIon::Get_phy_addr_from_ion(int buffer_fd, int *phy_addr, int *size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_phys_data phys_data;
+        struct ion_custom_data  custom_data;
+        phys_data.fd_buffer = buffer_fd;
+        custom_data.cmd = ION_SPRD_CUSTOM_PHYS;
+        custom_data.arg = (unsigned long)&phys_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        *phy_addr = phys_data.phys;
+        *size = phys_data.size;
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Getphyaddr error!",__func__);
+            return -2;
+        }
     }
-    ALOGE("MemoryHeapIon : Heap Mask flag is wrong (flags:%x)", flags);
     return 0;
 }
 
-uint32_t ion_FlagMask_valid_check(uint32_t flags)
+int MemoryHeapIon::get_phy_addr_from_ion(int *phy_addr, int *size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_phys_data phys_data;
+        struct ion_custom_data  custom_data;
+        phys_data.fd_buffer = MemoryHeapBase::getHeapID();
+        custom_data.cmd = ION_SPRD_CUSTOM_PHYS;
+        custom_data.arg = (unsigned long)&phys_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        *phy_addr = phys_data.phys;
+        *size = phys_data.size;
+        if(ret)
+        {
+            ALOGE("%s: getphyaddr error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::get_gsp_iova(int *mmu_addr, int *size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        if(ret)
+        {
+            ALOGE("%s: get gsp iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::free_gsp_iova(int mmu_addr, int size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        if(ret)
+        {
+            ALOGE("%s: free gsp iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::get_mm_iova(int *mmu_addr, int *size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        if(ret)
+        {
+            ALOGE("%s: get mm iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::free_mm_iova(int mmu_addr, int size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        if(ret)
+        {
+            ALOGE("%s: free mm iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+int MemoryHeapIon::Get_gsp_iova(int buffer_fd,int *mmu_addr, int *size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+
+        mmu_data.fd_buffer = buffer_fd;
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Get gsp iova error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+int MemoryHeapIon::Get_mm_iova(int buffer_fd,int *mmu_addr, int *size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+
+        mmu_data.fd_buffer =  buffer_fd;
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Get mm iova error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+
+int MemoryHeapIon::Free_gsp_iova(int buffer_fd,int mmu_addr, int size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+
+        mmu_data.fd_buffer = buffer_fd;
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Free gsp iova error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+int MemoryHeapIon::Free_mm_iova(int buffer_fd,int mmu_addr, int size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+
+        mmu_data.fd_buffer = buffer_fd;
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Free mm iova error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+
+bool MemoryHeapIon::Gsp_iommu_is_enabled(void)
 {
-    uint32_t flag_mask, result;
-    result = 0;
-
-    flag_mask = flags & FLAG_MASK_FILTER;
-
-    if (flag_mask & MHB_ION_FLAG_CACHED)
-        result |= ION_FLAG_CACHED;
-    if (flag_mask & MHB_ION_FLAG_CACHED_NEEDS_SYNC)
-        result |= ION_FLAG_CACHED_NEEDS_SYNC;
-    if (flag_mask & MHB_ION_FLAG_PRESERVE_KMAP)
-        result |= ION_FLAG_PRESERVE_KMAP;
-    if (flag_mask & MHB_ION_EXYNOS_VIDEO_MASK)
-        result |= ION_EXYNOS_VIDEO_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_MFC_INPUT_MASK)
-        result |= ION_EXYNOS_MFC_INPUT_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_MFC_OUTPUT_MASK)
-        result |= ION_EXYNOS_MFC_OUTPUT_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_GSC_MASK)
-        result |= ION_EXYNOS_GSC_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_FIMD_VIDEO_MASK)
-        result |= ION_EXYNOS_FIMD_VIDEO_MASK;
-
-    return result;
-}
-
-MemoryHeapIon::MemoryHeapIon(size_t size, uint32_t flags,
-    __attribute__((unused))char const *name):MemoryHeapBase()
+	if(access("/dev/sprd_iommu_gsp",F_OK)<0)
+	{
+		return false;
+	}
+	return true;
+}
+
+bool MemoryHeapIon::Mm_iommu_is_enabled(void)
 {
-    void* base = NULL;
-    int fd = -1;
-    uint32_t isReadOnly, heapMask, flagMask;
-
-    mIonClient = ion_client_create();
-
-    if (mIonClient < 0) {
-        ALOGE("MemoryHeapIon : ION client creation failed : %s", strerror(errno));
-        mIonClient = -1;
-    } else {
-        isReadOnly = flags & (IMemoryHeap::READ_ONLY);
-        heapMask = ion_HeapMask_valid_check(flags);
-        flagMask = ion_FlagMask_valid_check(flags);
-
-        if (heapMask) {
-            ALOGD("MemoryHeapIon : Allocated with size:%zu, heap:0x%X , flag:0x%X", size, heapMask, flagMask);
-            fd = ion_alloc(mIonClient, size, 0, heapMask, flagMask);
-            if (fd < 0) {
-                ALOGE("MemoryHeapIon : ION Reserve memory allocation failed(size[%zu]) : %s", size, strerror(errno));
-                if (errno == ENOMEM) { // Out of reserve memory. So re-try allocating in system heap
-                    ALOGD("MemoryHeapIon : Re-try Allocating in default heap - SYSTEM heap");
-                    fd = ion_alloc(mIonClient, size, 0, ION_HEAP_SYSTEM_MASK, ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC | ION_FLAG_PRESERVE_KMAP);
-                }
-            }
-        } else {
-            fd = ion_alloc(mIonClient, size, 0, ION_HEAP_SYSTEM_MASK, ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC | ION_FLAG_PRESERVE_KMAP);
-            ALOGD("MemoryHeapIon : Allocated with default heap - SYSTEM heap");
-        }
+	if(access("/dev/sprd_iommu_mm",F_OK)<0)
+	{
+		return false;
+	}
+	return true;
+}
 
-        flags = isReadOnly | heapMask | flagMask;
-
-        if (fd < 0) {
-            ALOGE("MemoryHeapIon : ION memory allocation failed(size[%zu]) : %s", size, strerror(errno));
-        } else {
-            flags |= USE_ION_FD;
-            base = ion_map(fd, size, 0);
-            if (base != MAP_FAILED) {
-                init(fd, base, size, flags, NULL);
-            } else {
-                ALOGE("MemoryHeapIon : ION mmap failed(size[%zu], fd[%d]) : %s", size, fd, strerror(errno));
-                ion_free(fd);
-            }
+int  MemoryHeapIon::Flush_ion_buffer(int buffer_fd, void *v_addr,void *p_addr,int size){
+       int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_msync_data msync_data;
+        struct ion_custom_data  custom_data;
+
+        msync_data.fd_buffer = buffer_fd;
+        msync_data.vaddr = v_addr;
+        msync_data.paddr = p_addr;
+        msync_data.size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MSYNC;
+        custom_data.arg = (unsigned long)&msync_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Flush ion buffer error!",__func__);
+            return -2;
         }
     }
+    return 0;
+}
+
+int MemoryHeapIon::flush_ion_buffer(void *v_addr, void *p_addr,int size){
+    if(mIonDeviceFd<0){
+        return -1;
+    }else{
+        int ret;
+        struct ion_msync_data msync_data;
+        struct ion_custom_data  custom_data;
+
+        if ((v_addr<MemoryHeapBase::getBase()) || (((char *)v_addr)+size>((char *)MemoryHeapBase::getBase())+MemoryHeapBase::getSize())){
+             ALOGE("flush_ion_buffer error  mBase=0x%x,mSize=0x%x",MemoryHeapBase::getBase(), MemoryHeapBase::getSize());
+             ALOGE("flush_ion_buffer error  v_addr=0x%x,p_addr=0x%x,size=0x%x",v_addr,p_addr,size);
+             return -3;
+        }
+        msync_data.fd_buffer = MemoryHeapBase::getHeapID();
+        msync_data.vaddr = v_addr;
+        msync_data.paddr = p_addr;
+        msync_data.size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MSYNC;
+        custom_data.arg = (unsigned long)&msync_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        if(ret)
+        {
+            ALOGE("%s:flush ion buffer error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+MemoryHeapIon::MemoryHeapIon() : mIonDeviceFd(-1), mIonHandle(NULL)
+{
 }
 
-MemoryHeapIon::MemoryHeapIon(int fd, size_t size, uint32_t flags,
-    __attribute__((unused))uint32_t offset):MemoryHeapBase()
+MemoryHeapIon::MemoryHeapIon(const char* device, size_t size,
+    uint32_t flags, unsigned long memory_types)
+    : MemoryHeapBase()
 {
-    void* base = NULL;
-    int dup_fd = -1;
-
-    mIonClient = ion_client_create();
-
-    if (mIonClient < 0) {
-        ALOGE("MemoryHeapIon : ION client creation failed : %s", strerror(errno));
-        mIonClient = -1;
-    } else {
-        if (fd >= 0) {
-            dup_fd = dup(fd);
-            if (dup_fd == -1) {
-                ALOGE("MemoryHeapIon : cannot dup fd (size[%zu], fd[%d]) : %s", size, fd, strerror(errno));
-            } else {
-                flags |= USE_ION_FD;
-                base = ion_map(dup_fd, size, 0);
-                if (base != MAP_FAILED) {
-                    init(dup_fd, base, size, flags, NULL);
-                } else {
-                    ALOGE("MemoryHeapIon : ION mmap failed(size[%zu], fd[%d]): %s", size, fd, strerror(errno));
-                    ion_free(dup_fd);
-                }
+    int open_flags = O_RDONLY;
+    if (flags & NO_CACHING)
+         open_flags |= O_SYNC;
+
+    int fd = open(device, open_flags);
+    if (fd >= 0) {
+            const size_t pagesize = getpagesize();
+            size = ((size + pagesize-1) & ~(pagesize-1));
+            if (mapIonFd(fd, size, memory_types, flags) == NO_ERROR) {
+                MemoryHeapBase::setDevice(device);
             }
-        } else {
-            ALOGE("MemoryHeapIon : fd parameter error(fd : %d)", fd);
+    }else {
+        ALOGE("open ion fail");
+    }
+}
+
+status_t MemoryHeapIon::ionInit(int ionFd, void *base, int size, int flags,
+                const char* device, struct ion_handle *handle,
+                int ionMapFd) {
+    mIonDeviceFd = ionFd;
+    mIonHandle = handle;
+    MemoryHeapBase::init(ionMapFd, base, size, flags, device);
+    return NO_ERROR;
+}
+
+
+status_t MemoryHeapIon::mapIonFd(int fd, size_t size, unsigned long memory_type, int uflags)
+{
+    /* If size is 0, just fail the mmap. There is no way to get the size
+     * with ion
+     */
+    int map_fd;
+
+    struct ion_allocation_data data;
+    struct ion_fd_data fd_data;
+    struct ion_handle_data handle_data;
+    void *base = NULL;
+
+    data.len = size;
+    data.align = getpagesize();
+#if (ION_DRIVER_VERSION == 1)
+    data.heap_mask = memory_type;
+    //if cached buffer , force set the lowest two bits 11
+    if((memory_type&(1<<31)))
+    {
+        data.flags = ((memory_type&(1<<31)) | 3);
+    }
+    else
+    {
+        data.flags = 0;
+    }
+#else
+    data.flags = memory_type;
+#endif
+
+    if (ioctl(fd, ION_IOC_ALLOC, &data) < 0) {
+        ALOGE("%s: ION_IOC_ALLOC error!",__func__);
+        close(fd);
+        return -errno;
+    }
+
+    if ((uflags & DONT_MAP_LOCALLY) == 0) {
+        int flags = 0;
+
+        fd_data.handle = data.handle;
+
+        if (ioctl(fd, ION_IOC_SHARE, &fd_data) < 0) {
+            ALOGE("%s: ION_IOC_SHARE error!",__func__);
+            handle_data.handle = data.handle;
+            ioctl(fd, ION_IOC_FREE, &handle_data);
+            close(fd);
+            return -errno;
+        }
+
+        base = (uint8_t*)mmap(0, size,
+                PROT_READ|PROT_WRITE, MAP_SHARED|flags, fd_data.fd, 0);
+        if (base == MAP_FAILED) {
+            ALOGE("mmap(fd=%d, size=%u) failed (%s)",
+                    fd, uint32_t(size), strerror(errno));
+            handle_data.handle = data.handle;
+            ioctl(fd, ION_IOC_FREE, &handle_data);
+            close(fd);
+            return -errno;
         }
     }
+    mIonHandle = data.handle;
+    mIonDeviceFd = fd;
+
+    /*
+     * Call this with NULL now and set device with set_device
+     * above for consistency sake with how MemoryHeapPmem works.
+     */
+    MemoryHeapBase::init(fd_data.fd, base, size, uflags, NULL);
+
+    return NO_ERROR;
 }
 
 MemoryHeapIon::~MemoryHeapIon()
 {
-    if (mIonClient != -1) {
-        ion_unmap(getBase(), getSize());
-        ion_client_destroy(mIonClient);
-        mIonClient = -1;
+    struct ion_handle_data data;
+
+    data.handle = mIonHandle;
+
+    /*
+     * Due to the way MemoryHeapBase is set up, munmap will never
+     * be called so we need to call it ourselves here.
+     */
+    munmap(MemoryHeapBase::getBase(), MemoryHeapBase::getSize());
+    if (mIonDeviceFd > 0) {
+        ioctl(mIonDeviceFd, ION_IOC_FREE, &data);
+        close(mIonDeviceFd);
     }
 }
 
-};
+// ---------------------------------------------------------------------------
+}; // namespace android
+
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 76aec6e..bc556e9 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -80,6 +80,11 @@ LOCAL_SHARED_LIBRARIES := \
 	libui \
 	libutils \
 	liblog
+	
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
+
 
 
 LOCAL_MODULE := libgui
diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index 0ad6339..18bd396 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -97,6 +97,33 @@ public:
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
         remote()->transact(BnSurfaceComposer::BOOT_FINISHED, data, &reply);
     }
+    
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(
+            const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform,
+            ISurfaceComposer::Rotation rotation)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
+        data.writeStrongBinder(display);
+        data.write(sourceCrop);
+        data.writeUint32(reqWidth);
+        data.writeUint32(reqHeight);
+        data.writeUint32(minLayerZ);
+        data.writeUint32(maxLayerZ);
+        data.writeInt32(static_cast<int32_t>(useIdentityTransform));
+        data.writeInt32(static_cast<int32_t>(rotation));
+        remote()->transact(BnSurfaceComposer::CAPTURE_SCREEN_DEPRECATED, data, &reply);
+        *heap = interface_cast<IMemoryHeap>(reply.readStrongBinder());
+        *width = reply.readUint32();
+        *height = reply.readUint32();
+        return reply.readInt32();
+    }
+#endif
 
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
@@ -350,6 +377,31 @@ status_t BnSurfaceComposer::onTransact(
             bootFinished();
             return NO_ERROR;
         }
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED: {
+            CHECK_INTERFACE(ISurfaceComposer, data, reply);
+            sp<IBinder> display = data.readStrongBinder();
+            Rect sourceCrop;
+            data.read(sourceCrop);
+            uint32_t reqWidth = data.readUint32();
+            uint32_t reqHeight = data.readUint32();
+            uint32_t minLayerZ = data.readUint32();
+            uint32_t maxLayerZ = data.readUint32();
+            bool useIdentityTransform = static_cast<bool>(data.readInt32());
+            uint32_t rotation = data.readUint32();
+            sp<IMemoryHeap> heap;
+            uint32_t w, h;
+            status_t res = captureScreen(display, &heap, &w, &h,
+                    sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                    useIdentityTransform,
+                    static_cast<ISurfaceComposer::Rotation>(rotation));
+            reply->writeStrongBinder(IInterface::asBinder(heap));
+            reply->writeUint32(w);
+            reply->writeUint32(h);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }
+#endif
         case CAPTURE_SCREEN: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
diff --git a/libs/gui/SurfaceComposerClient.cpp b/libs/gui/SurfaceComposerClient.cpp
index 82bdd6b..7b67d96 100644
--- a/libs/gui/SurfaceComposerClient.cpp
+++ b/libs/gui/SurfaceComposerClient.cpp
@@ -751,11 +751,11 @@ status_t SurfaceComposerClient::getAnimationFrameStats(FrameStats* outStats) {
 
 // ----------------------------------------------------------------------------
 
-#ifndef FORCE_SCREENSHOT_CPU_PATH
+/*#ifndef FORCE_SCREENSHOT_CPU_PATH
 #define SS_CPU_CONSUMER false
 #else
 #define SS_CPU_CONSUMER true
-#endif
+#endif*/
 
 status_t ScreenshotClient::capture(
         const sp<IBinder>& display,
@@ -764,9 +764,17 @@ status_t ScreenshotClient::capture(
         uint32_t minLayerZ, uint32_t maxLayerZ, bool useIdentityTransform) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#ifdef USE_MHEAP_SCREENSHOT
+    int format = 0;
+    producer->query(NATIVE_WINDOW_FORMAT,&format);
+    if (format == PIXEL_FORMAT_RGBA_8888) {
+        /* For some reason, this format fails badly */
+        return BAD_VALUE;
+    }
+#endif
     return s->captureScreen(display, producer, sourceCrop,
             reqWidth, reqHeight, minLayerZ, maxLayerZ, useIdentityTransform,
-            ISurfaceComposer::eRotateNone, SS_CPU_CONSUMER);
+            ISurfaceComposer::eRotateNone, false /*SS_CPU_CONSUMER*/);
 }
 
 ScreenshotClient::ScreenshotClient()
@@ -794,6 +802,19 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
         bool useIdentityTransform, uint32_t rotation) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#ifdef USE_MHEAP_SCREENSHOT
+    int ret = -1;
+    mHeap = 0;
+    ret = s->captureScreen(display, &mHeap, &mBuffer.width, &mBuffer.height, sourceCrop,
+            reqWidth, reqHeight, minLayerZ, maxLayerZ, useIdentityTransform,
+            static_cast<ISurfaceComposer::Rotation>(rotation));
+    if (ret == NO_ERROR) {
+        mBuffer.format = PIXEL_FORMAT_RGBA_8888;
+        mBuffer.stride = mBuffer.width;
+        mBuffer.data = static_cast<uint8_t*>(mHeap->getBase());
+    }
+    return ret;
+#else
     sp<CpuConsumer> cpuConsumer = getCpuConsumer();
 
     if (mHaveBuffer) {
@@ -813,6 +834,7 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
         }
     }
     return err;
+#endif
 }
 
 status_t ScreenshotClient::update(const sp<IBinder>& display,
@@ -837,12 +859,16 @@ status_t ScreenshotClient::update(const sp<IBinder>& display, Rect sourceCrop,
 }
 
 void ScreenshotClient::release() {
+#ifdef USE_MHEAP_SCREENSHOT
+    mHeap = 0;
+#else
     if (mHaveBuffer) {
         mCpuConsumer->unlockBuffer(mBuffer);
         memset(&mBuffer, 0, sizeof(mBuffer));
         mHaveBuffer = false;
     }
     mCpuConsumer.clear();
+#endif
 }
 
 void const* ScreenshotClient::getPixels() const {
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index 25fa503..5d0e3e5 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -69,6 +69,14 @@ ifeq ($(TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK),true)
     LOCAL_CFLAGS += -DRUNNING_WITHOUT_SYNC_FRAMEWORK
 endif
 
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
+
+ifeq ($(BOARD_EGL_NEEDS_FNW),true)
+    LOCAL_CFLAGS += -DEGL_NEEDS_FNW
+endif
+
 # See build/target/board/generic/BoardConfig.mk for a description of this setting.
 ifneq ($(VSYNC_EVENT_PHASE_OFFSET_NS),)
     LOCAL_CFLAGS += -DVSYNC_EVENT_PHASE_OFFSET_NS=$(VSYNC_EVENT_PHASE_OFFSET_NS)
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index b83149b..6854b61 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -29,6 +29,10 @@
 
 #include <gui/Surface.h>
 
+#ifdef EGL_NEEDS_FNW
+#include <ui/FramebufferNativeWindow.h>
+#endif
+
 #include <hardware/gralloc.h>
 
 #include "DisplayHardware/DisplaySurface.h"
@@ -90,7 +94,11 @@ DisplayDevice::DisplayDevice(
 {
     Surface* surface;
     mNativeWindow = surface = new Surface(producer, false);
-    ANativeWindow* const window = mNativeWindow.get();
+#ifndef EGL_NEEDS_FNW
+     ANativeWindow* const window = mNativeWindow.get();
+#else
+    ANativeWindow* const window = new FramebufferNativeWindow();
+#endif
     char property[PROPERTY_VALUE_MAX];
 
     /*
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 441bad8..608db29 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -26,6 +26,9 @@
 #include <stdatomic.h>
 
 #include <EGL/egl.h>
+#ifdef USE_MHEAP_SCREENSHOT
+#include <GLES/gl.h>
+#endif
 
 #include <cutils/log.h>
 #include <cutils/iosched_policy.h>
@@ -3062,12 +3065,18 @@ status_t SurfaceFlinger::onTransact(
             break;
         }
         case CAPTURE_SCREEN:
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED:
+#endif
         {
             // codes that require permission check
             IPCThreadState* ipc = IPCThreadState::self();
             const int pid = ipc->getCallingPid();
             const int uid = ipc->getCallingUid();
             if ((uid != AID_GRAPHICS) &&
+#ifdef USE_MHEAP_SCREENSHOT
+                 (uid != AID_SYSTEM) &&
+#endif
                     !PermissionCache::checkPermission(sReadFramebuffer, pid, uid)) {
                 ALOGE("Permission Denial: "
                         "can't read framebuffer pid=%d, uid=%d", pid, uid);
@@ -3427,9 +3436,18 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
             Mutex::Autolock _l(flinger->mStateLock);
             sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
             bool useReadPixels = this->useReadPixels && !flinger->mGpuToCpuSupported;
-            result = flinger->captureScreenImplLocked(hw, producer,
-                    sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
-                    useIdentityTransform, rotation, useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            if (!useReadPixels) {
+#endif
+                result = flinger->captureScreenImplLocked(hw, producer,
+                        sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                        useIdentityTransform, rotation, useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            } else {
+                // Should never get here
+                return BAD_VALUE;
+            }
+#endif
             static_cast<GraphicProducerWrapper*>(IInterface::asBinder(producer).get())->exit(result);
             return true;
         }
@@ -3748,6 +3766,140 @@ void SurfaceFlinger::drawWormHoleIfRequired(HWComposer::LayerListIterator& /*cur
     drawWormhole(hw, region);
 }
 
+#ifdef USE_MHEAP_SCREENSHOT
+status_t SurfaceFlinger::captureScreenImplCpuConsumerLocked(
+        const sp<const DisplayDevice>& hw,
+        sp<IMemoryHeap>* heap, uint32_t* w, uint32_t* h,
+        Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useIdentityTransform, Transform::orientation_flags rotation)
+{
+    ATRACE_CALL();
+
+    // get screen geometry
+    const uint32_t hw_w = hw->getWidth();
+    const uint32_t hw_h = hw->getHeight();
+
+    if ((reqWidth > hw_w) || (reqHeight > hw_h)) {
+        ALOGE("size mismatch (%d, %d) > (%d, %d)",
+                reqWidth, reqHeight, hw_w, hw_h);
+        return BAD_VALUE;
+    }
+
+    reqWidth  = (!reqWidth)  ? hw_w : reqWidth;
+    reqHeight = (!reqHeight) ? hw_h : reqHeight;
+
+    status_t result = NO_ERROR;
+
+    renderScreenImplLocked(
+        hw, sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ, true,
+        useIdentityTransform, rotation);
+
+    size_t size = reqWidth * reqHeight * 4;
+    // allocate shared memory large enough to hold the
+    // screen capture
+    sp<MemoryHeapBase> base(
+            new MemoryHeapBase(size, 0, "screen-capture") );
+    void *vaddr = base->getBase();
+    glReadPixels(0, 0, reqWidth, reqHeight,
+            GL_RGBA, GL_UNSIGNED_BYTE, vaddr);
+    if (glGetError() == GL_NO_ERROR) {
+        *heap = base;
+        *w = reqWidth;
+        *h = reqHeight;
+        result = NO_ERROR;
+    } else {
+        result = INVALID_OPERATION;
+    }
+
+    return result;
+}
+
+status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
+        sp<IMemoryHeap>* heap, uint32_t* outWidth, uint32_t* outHeight,
+        Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useIdentityTransform, ISurfaceComposer::Rotation rotation)
+{
+    if (CC_UNLIKELY(display == 0))
+        return BAD_VALUE;
+
+    // Convert to surfaceflinger's internal rotation type.
+    Transform::orientation_flags rotationFlags;
+    switch (rotation) {
+        case ISurfaceComposer::eRotateNone:
+            rotationFlags = Transform::ROT_0;
+            break;
+        case ISurfaceComposer::eRotate90:
+            rotationFlags = Transform::ROT_90;
+            break;
+        case ISurfaceComposer::eRotate180:
+            rotationFlags = Transform::ROT_180;
+            break;
+        case ISurfaceComposer::eRotate270:
+            rotationFlags = Transform::ROT_270;
+            break;
+        default:
+            rotationFlags = Transform::ROT_0;
+            ALOGE("Invalid rotation passed to captureScreen(): %d\n", rotation);
+            break;
+    }
+
+    class MessageCaptureScreen : public MessageBase {
+        SurfaceFlinger* flinger;
+        sp<IBinder> display;
+        sp<IMemoryHeap>* heap;
+        uint32_t* outWidth;
+        uint32_t* outHeight;
+        Rect sourceCrop;
+        uint32_t reqWidth, reqHeight;
+        uint32_t minLayerZ,maxLayerZ;
+        bool useIdentityTransform;
+        Transform::orientation_flags rotation;
+        status_t result;
+    public:
+        MessageCaptureScreen(SurfaceFlinger* flinger,
+                const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+                uint32_t* outWidth, uint32_t* outHeight,
+                Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+                uint32_t minLayerZ, uint32_t maxLayerZ,
+                bool useIdentityTransform, Transform::orientation_flags rotation)
+            : flinger(flinger), display(display), heap(heap),
+              outWidth(outWidth), outHeight(outHeight),
+              sourceCrop(sourceCrop), reqWidth(reqWidth), reqHeight(reqHeight),
+              minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              useIdentityTransform(useIdentityTransform),
+              rotation(rotation),
+              result(PERMISSION_DENIED)
+        {
+        }
+        status_t getResult() const {
+            return result;
+        }
+        virtual bool handler() {
+            Mutex::Autolock _l(flinger->mStateLock);
+            sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
+            result = flinger->captureScreenImplCpuConsumerLocked(hw, heap,
+                    outWidth, outHeight,
+                    sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                    useIdentityTransform, rotation);
+            return true;
+        }
+    };
+
+    sp<MessageBase> msg = new MessageCaptureScreen(this, display, heap,
+            outWidth, outHeight,
+            sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+            useIdentityTransform, rotationFlags);
+    status_t res = postMessageSync(msg);
+    if (res == NO_ERROR) {
+        res = static_cast<MessageCaptureScreen*>( msg.get() )->getResult();
+    }
+    return res;
+}
+#endif
+
+
 // ---------------------------------------------------------------------------
 
 SurfaceFlinger::LayerVector::LayerVector() {
@@ -3794,6 +3946,7 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 }; // namespace android
 
 
+#ifndef USE_MHEAP_SCREENSHOT
 #if defined(__gl_h_)
 #error "don't include gl/gl.h in this file"
 #endif
@@ -3801,3 +3954,4 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 #if defined(__gl2_h_)
 #error "don't include gl2/gl2.h in this file"
 #endif
+#endif
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index 2003d6e..6015cf0 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -221,6 +221,13 @@ private:
             uint32_t minLayerZ, uint32_t maxLayerZ,
             bool useIdentityTransform, ISurfaceComposer::Rotation rotation,
             bool isCpuConsumer);
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform, ISurfaceComposer::Rotation rotation);
+#endif
     virtual status_t getDisplayStats(const sp<IBinder>& display,
             DisplayStatInfo* stats);
     virtual status_t getDisplayConfigs(const sp<IBinder>& display,
@@ -385,6 +392,16 @@ private:
             uint32_t minLayerZ, uint32_t maxLayerZ,
             bool useIdentityTransform, Transform::orientation_flags rotation,
             bool useReadPixels);
+            
+#ifdef USE_MHEAP_SCREENSHOT
+    status_t captureScreenImplCpuConsumerLocked(
+            const sp<const DisplayDevice>& hw,
+            sp<IMemoryHeap>* heap, uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform, Transform::orientation_flags rotation);
+#endif
+
 
     /* ------------------------------------------------------------------------
      * EGL
